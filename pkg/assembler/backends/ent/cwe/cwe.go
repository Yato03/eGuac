// Code generated by ent, DO NOT EDIT.

package cwe

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

const (
	// Label holds the string label denoting the cwe type in the database.
	Label = "cwe"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldVexID holds the string denoting the vex_id field in the database.
	FieldVexID = "vex_id"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldDescription holds the string denoting the description field in the database.
	FieldDescription = "description"
	// FieldBackgroundDetail holds the string denoting the background_detail field in the database.
	FieldBackgroundDetail = "background_detail"
	// EdgeCertifyVex holds the string denoting the certify_vex edge name in mutations.
	EdgeCertifyVex = "certify_vex"
	// EdgeConsequence holds the string denoting the consequence edge name in mutations.
	EdgeConsequence = "consequence"
	// EdgeDemonstrativeExample holds the string denoting the demonstrative_example edge name in mutations.
	EdgeDemonstrativeExample = "demonstrative_example"
	// EdgeDetectionMethod holds the string denoting the detection_method edge name in mutations.
	EdgeDetectionMethod = "detection_method"
	// EdgePotentialMitigation holds the string denoting the potential_mitigation edge name in mutations.
	EdgePotentialMitigation = "potential_mitigation"
	// Table holds the table name of the cwe in the database.
	Table = "cw_es"
	// CertifyVexTable is the table that holds the certify_vex relation/edge. The primary key declared below.
	CertifyVexTable = "certify_vex_cwe"
	// CertifyVexInverseTable is the table name for the CertifyVex entity.
	// It exists in this package in order to avoid circular dependency with the "certifyvex" package.
	CertifyVexInverseTable = "certify_vexes"
	// ConsequenceTable is the table that holds the consequence relation/edge. The primary key declared below.
	ConsequenceTable = "cwe_consequence"
	// ConsequenceInverseTable is the table name for the Consequence entity.
	// It exists in this package in order to avoid circular dependency with the "consequence" package.
	ConsequenceInverseTable = "consequences"
	// DemonstrativeExampleTable is the table that holds the demonstrative_example relation/edge. The primary key declared below.
	DemonstrativeExampleTable = "cwe_demonstrative_example"
	// DemonstrativeExampleInverseTable is the table name for the DemonstrativeExample entity.
	// It exists in this package in order to avoid circular dependency with the "demonstrativeexample" package.
	DemonstrativeExampleInverseTable = "demonstrative_examples"
	// DetectionMethodTable is the table that holds the detection_method relation/edge. The primary key declared below.
	DetectionMethodTable = "cwe_detection_method"
	// DetectionMethodInverseTable is the table name for the DetectionMethod entity.
	// It exists in this package in order to avoid circular dependency with the "detectionmethod" package.
	DetectionMethodInverseTable = "detection_methods"
	// PotentialMitigationTable is the table that holds the potential_mitigation relation/edge. The primary key declared below.
	PotentialMitigationTable = "cwe_potential_mitigation"
	// PotentialMitigationInverseTable is the table name for the PotentialMitigation entity.
	// It exists in this package in order to avoid circular dependency with the "potentialmitigation" package.
	PotentialMitigationInverseTable = "potential_mitigations"
)

// Columns holds all SQL columns for cwe fields.
var Columns = []string{
	FieldID,
	FieldVexID,
	FieldName,
	FieldDescription,
	FieldBackgroundDetail,
}

var (
	// CertifyVexPrimaryKey and CertifyVexColumn2 are the table columns denoting the
	// primary key for the certify_vex relation (M2M).
	CertifyVexPrimaryKey = []string{"certify_vex_id", "cwe_id"}
	// ConsequencePrimaryKey and ConsequenceColumn2 are the table columns denoting the
	// primary key for the consequence relation (M2M).
	ConsequencePrimaryKey = []string{"cwe_id", "consequence_id"}
	// DemonstrativeExamplePrimaryKey and DemonstrativeExampleColumn2 are the table columns denoting the
	// primary key for the demonstrative_example relation (M2M).
	DemonstrativeExamplePrimaryKey = []string{"cwe_id", "demonstrative_example_id"}
	// DetectionMethodPrimaryKey and DetectionMethodColumn2 are the table columns denoting the
	// primary key for the detection_method relation (M2M).
	DetectionMethodPrimaryKey = []string{"cwe_id", "detection_method_id"}
	// PotentialMitigationPrimaryKey and PotentialMitigationColumn2 are the table columns denoting the
	// primary key for the potential_mitigation relation (M2M).
	PotentialMitigationPrimaryKey = []string{"cwe_id", "potential_mitigation_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultID holds the default value on creation for the "id" field.
	DefaultID func() uuid.UUID
)

// OrderOption defines the ordering options for the CWE queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByVexID orders the results by the vex_id field.
func ByVexID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldVexID, opts...).ToFunc()
}

// ByName orders the results by the name field.
func ByName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldName, opts...).ToFunc()
}

// ByDescription orders the results by the description field.
func ByDescription(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDescription, opts...).ToFunc()
}

// ByBackgroundDetail orders the results by the background_detail field.
func ByBackgroundDetail(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBackgroundDetail, opts...).ToFunc()
}

// ByCertifyVexCount orders the results by certify_vex count.
func ByCertifyVexCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newCertifyVexStep(), opts...)
	}
}

// ByCertifyVex orders the results by certify_vex terms.
func ByCertifyVex(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCertifyVexStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByConsequenceCount orders the results by consequence count.
func ByConsequenceCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newConsequenceStep(), opts...)
	}
}

// ByConsequence orders the results by consequence terms.
func ByConsequence(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newConsequenceStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByDemonstrativeExampleCount orders the results by demonstrative_example count.
func ByDemonstrativeExampleCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newDemonstrativeExampleStep(), opts...)
	}
}

// ByDemonstrativeExample orders the results by demonstrative_example terms.
func ByDemonstrativeExample(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newDemonstrativeExampleStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByDetectionMethodCount orders the results by detection_method count.
func ByDetectionMethodCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newDetectionMethodStep(), opts...)
	}
}

// ByDetectionMethod orders the results by detection_method terms.
func ByDetectionMethod(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newDetectionMethodStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByPotentialMitigationCount orders the results by potential_mitigation count.
func ByPotentialMitigationCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newPotentialMitigationStep(), opts...)
	}
}

// ByPotentialMitigation orders the results by potential_mitigation terms.
func ByPotentialMitigation(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPotentialMitigationStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newCertifyVexStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CertifyVexInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, CertifyVexTable, CertifyVexPrimaryKey...),
	)
}
func newConsequenceStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ConsequenceInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, ConsequenceTable, ConsequencePrimaryKey...),
	)
}
func newDemonstrativeExampleStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(DemonstrativeExampleInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, DemonstrativeExampleTable, DemonstrativeExamplePrimaryKey...),
	)
}
func newDetectionMethodStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(DetectionMethodInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, DetectionMethodTable, DetectionMethodPrimaryKey...),
	)
}
func newPotentialMitigationStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PotentialMitigationInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, PotentialMitigationTable, PotentialMitigationPrimaryKey...),
	)
}
